import socket
import threading
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.backends import default_backend

proxy_host = '127.0.0.1'
proxy_port = 8888

destination_host = 'example.com'
destination_port = 80

def load_private_key():
    with open("private_key.pem", "rb") as key_file:
        private_key = serialization.load_pem_private_key(
            key_file.read(),
            password=None,
            backend=default_backend()
        )
        return private_key

def load_public_key():
    with open("public_key.pem", "rb") as key_file:
        public_key = serialization.load_pem_public_key(
            key_file.read(),
            backend=default_backend()
        )
        return public_key

def encrypt_data(data, public_key):
    encrypted_data = public_key.encrypt(
        data,
        padding.OAEP(
            mgf=padding.MGF1(algorithm=padding.Algorithm.SHA256),
            algorithm=padding.Algorithm.OAEP,
            label=None
        )
    )
    return encrypted_data

def decrypt_data(data, private_key):
    decrypted_data = private_key.decrypt(
        data,
        padding.OAEP(
            mgf=padding.MGF1(algorithm=padding.Algorithm.SHA256),
            algorithm=padding.Algorithm.OAEP,
            label=None
        )
    )
    return decrypted_data

def handle_client(client_socket, private_key, public_key):
    destination_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    destination_socket.connect((destination_host, destination_port))

    while True:
        client_data = client_socket.recv(4096)
        if not client_data:
            break

        encrypted_data = encrypt_data(client_data, public_key)
        destination_socket.sendall(encrypted_data)

        destination_data = destination_socket.recv(4096)
        if not destination_data:
            break
        
        decrypted_data = decrypt_data(destination_data, private_key)
        client_socket.sendall(decrypted_data)

    client_socket.close()
    destination_socket.close()

def start_proxy():
    private_key = load_private_key()
    public_key = load_public_key()

    proxy_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    proxy_socket.bind((proxy_host, proxy_port))
    proxy_socket.listen(5)
    print(f"[*] Proxy listening on {proxy_host}:{proxy_port}")

    while True:
        client_socket, addr = proxy_socket.accept()
        print(f"[*] Accepted connection from {addr[0]}:{addr[1]}")
        
        client_handler = threading.Thread(target=handle_client, args=(client_socket, private_key, public_key))
        client_handler.start()

if __name__ == "__main__":
    start_proxy()
